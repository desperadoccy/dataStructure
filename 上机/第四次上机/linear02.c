/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//问题描述：请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。
//1、假设一节车厢有5排、每一排5个座位。为方便起见，我们用1到25来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，
//   第5排是21到25号。
//2、购票时，单次可以购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。
//   否则应该安排在编号最小的几个空座位中（不考虑是否相邻）；
//3、假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。   
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//题目要求：
// 1、程序运行时，首先提示用户输入购票数n，n必须小于等于5。如果系统中剩余票数还大于等于n，那么请给出n张票的购票结果，
//    按照从小到大的顺序输出票号；如果系统中当前剩余的票数小于n，则提示用户剩余票数已不够，可以重新输入购票数；如果
//    输入的n小于或等于0，程序结束。        
// 2、如果还有剩余票，则提示剩余票数，并提示可以继续输入购票数n，根据n的数值继续重复上述步骤，直到系统中已经没有剩票或者n小于或等于0 
// 3、样例：如果首先输入2，则输出应该是1,2；还剩余23张票
//          继续输入5，输出应该是6,7,8,9,10；还剩余18张票
//          继续输入4，输出应该是11,12,13,14;还剩余14张票
//          继续输入2，输出应该是3,4；还剩余12张票
//          继续输入3，输出应该是16,17,18；还剩余9张票
//          继续输入4，输出应该是21,22,23,24；还剩余5张票
//          继续输入4，输出应该是5,15,19,20；还剩余1张票
//          继续输入0，程序结束
//
//
//     
// 4、请自行设计数据结构与算法，分析算法复杂度 
//     
//学   号：161830218                                                                                                       
//姓   名：陈楚D                                                                                                          
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




#include "stdlib.h"
#include "math.h"
#include "stdio.h"
#define N 5
#define M 5
//M为排数，N为一排座位数 

int main()
{
	int i,j,n,pos = 0,cnt = M*N;
	int Mmax; //最多可以连座的人数 
	int ticket[M]; //每排剩的票数 
	for(i = 0; i < M; i++)
		ticket[i] = N;
	while(1)
	{
		printf("现剩余%d张票，请输入购票数：\n", cnt);
		scanf("%d", &n);
		if(n <= 0) break;
		//如果大于总数，直接退出 
		if(n > cnt) 
		{
			printf("余票不足\n");
			continue;
		}
		cnt -= n;
		//找出是否可以连座 
		Mmax = ticket[pos];
		for(i = pos+1;i < M; i++)
			if(ticket[i] > Mmax)
				Mmax = ticket[i];
		//不可以连座 
		if(n > Mmax)
		{
			for(i = pos; i < M; i++)
			{
				if(ticket[i] > n)
				{
					int tmp = ticket[i];
					ticket[i] -= n; 
					for(j = N*(i+1)-tmp+1; j <= N*(i+1)-tmp+n; j++)
						printf("%d ", j);
					break;
				}
				else if(ticket[i] != 0)
				{
					int tmp = ticket[i];
					n -= ticket[j];
					for(j = N*(i+1)-tmp+1; j <= N*(i+1); j++)
						printf("%d ", j);
					pos++;
				}
			}
		}
		//可以连座 
		else
		{
			for(i = pos; i < M; i++)
			{
				if(ticket[i] >= n)
				{
					int tmp = ticket[i];
					ticket[i] -= n;
					for(j = N*(i+1)-tmp+1; j <= N*(i+1)-tmp+n; j++)
						printf("%d ", j);
					break;
				}
			}
		}
		printf("\n");
	}
	return 0;
}
